{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/DoctorType.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\t\r\n\r\npragma solidity ^0.8.7;\r\n\r\n\r\nlibrary DoctorType {\r\n    //Type Declaration\r\n    struct Doctor {\r\n        address doctorAddress; //account address of doctor\r\n        string name;\r\n        string doctorRegistrationId; //NMC Regsitration Id\r\n        uint256 dateOfRegistration;\r\n        string specialization;\r\n        address hospitalAddress;\r\n    }\r\n}"
    },
    "contracts/HospitalType.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\t\r\n\r\npragma solidity ^0.8.7;\r\n\r\nlibrary HospitalType{\r\n    //Type Declaration\r\n\r\n    struct Hospital{\r\n        string name;\r\n        address hospitalAddress; //account address of hospital\r\n        uint256 dateOfRegistration;\r\n        string hospitalRegistrationId;\r\n        string email;\r\n        string phoneNumber;\r\n    }\r\n}"
    },
    "contracts/PatientMedicalRecordSystem.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\t\r\n\r\npragma solidity ^0.8.7;\r\n\r\n/// @title A smart contract supporting the Decentralized Patient Medical Record System\r\n/// @author Aditya Kumar Singh @ July 2022\r\n/// @notice This smart contract is a part of my 2nd Year Summer Project\r\n/// @dev All function calls are currently implemented without side effects\r\n\r\n//imports\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport {DoctorType} from \"./DoctorType.sol\";\r\nimport {HospitalType} from \"./HospitalType.sol\";\r\nimport {PatientType} from \"./PatientType.sol\";\r\n\r\n//errors\r\nerror PatientMedicalRecords__NotOwner();\r\nerror PatientMedicalRecords__NotDoctor();\r\nerror PatientMedicalRecords__NotApproved();\r\nerror PatientMedicalRecords__NotPatient();\r\n\r\ncontract PatientMedicalRecordSystem is ReentrancyGuard {\r\n    //Type Declaration\r\n\r\n    //Storage Variables\r\n    mapping(address => PatientType.Patient) private s_patients;\r\n    mapping(address => DoctorType.Doctor) private s_doctors;\r\n    mapping(address => HospitalType.Hospital) private s_hospitals;\r\n    mapping(address => string) private s_addressToPublicKey;\r\n\r\n    address private immutable i_owner;\r\n\r\n    //Events\r\n    event AddedPatient(\r\n        address indexed patientAddress,\r\n        string name,\r\n        string[] chronicHash,\r\n        uint256 indexed dob,\r\n        string bloodGroup,\r\n        uint256 indexed dateOfRegistration,\r\n        string publicKey,\r\n        string[] vaccinationHash,\r\n        string phoneNumber,\r\n        string[] accidentHash,\r\n        string[] acuteHash\r\n    ); //added or modified\r\n\r\n    event AddedPublicKey(address indexed patientAddress, string publicKey); //emitting when public key is added.\r\n\r\n    event AddedDoctor(\r\n        address indexed doctorAddress,\r\n        string name,\r\n        string doctorRegistrationId,\r\n        uint256 indexed dateOfRegistration,\r\n        string specialization,\r\n        address indexed hospitalAddress\r\n    ); //added or modified to the mapping\r\n    event AddedHospital(\r\n        address indexed hospitalAddress,\r\n        string name,\r\n        string hospitalRegistrationId,\r\n        uint256 indexed dateOfRegistration,\r\n        string email,\r\n        string phoneNumber\r\n    ); //added(mostly) or modified\r\n\r\n    //modifiers\r\n    modifier onlyOwner() {\r\n        if (msg.sender != i_owner) {\r\n            revert PatientMedicalRecords__NotOwner();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyDoctor(address senderAddress) {\r\n        if (s_doctors[senderAddress].doctorAddress != senderAddress) {\r\n            revert PatientMedicalRecords__NotDoctor();\r\n        }\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        i_owner = msg.sender;\r\n    }\r\n\r\n    //Functions\r\n    //patients can themselves register to the system.\r\n    function registerPatient(\r\n        address _patientAddress,\r\n        string memory _name,\r\n        uint256 _dob,\r\n        string memory _phoneNumber,\r\n        string memory _bloodGroup,\r\n        string memory _publicKey\r\n    ) external nonReentrant {\r\n        if (msg.sender != _patientAddress) {\r\n            revert PatientMedicalRecords__NotPatient();\r\n        }\r\n        PatientType.Patient memory patient;\r\n        patient.name = _name;\r\n        patient.patientAddress = _patientAddress;\r\n        patient.dob = _dob;\r\n        patient.phoneNumber = _phoneNumber;\r\n        patient.bloodGroup = _bloodGroup;\r\n        patient.dateOfRegistration = block.timestamp;\r\n        patient.publicKey = _publicKey; //public key is stored here.\r\n\r\n        patient.vaccinationHash = new string[](0); //0\r\n        patient.accidentHash = new string[](0); // 1\r\n        patient.chronicHash = new string[](0); //2\r\n        patient.acuteHash = new string[](0); //3\r\n\r\n        s_patients[_patientAddress] = patient;\r\n        s_addressToPublicKey[_patientAddress] = _publicKey;\r\n\r\n        //emiting the events\r\n        emit AddedPublicKey(_patientAddress, _publicKey);\r\n        emit AddedPatient(\r\n            _patientAddress,\r\n            patient.name,\r\n            patient.chronicHash,\r\n            patient.dob,\r\n            patient.bloodGroup,\r\n            patient.dateOfRegistration,\r\n            patient.publicKey,\r\n            patient.vaccinationHash,\r\n            patient.phoneNumber,\r\n            patient.accidentHash,\r\n            patient.acuteHash\r\n        );\r\n    }\r\n\r\n    function addPatientDetails(\r\n        address _patientAddress,\r\n        uint16 _category,\r\n        string memory _IpfsHash //This is the IPFS hash of the diagnostic report which contains an IPFS file hash (preferably PDF file)\r\n    ) external onlyDoctor(msg.sender) nonReentrant {\r\n        if (_category == 0) {\r\n            s_patients[_patientAddress].vaccinationHash.push(_IpfsHash);\r\n        } else if (_category == 1) {\r\n            s_patients[_patientAddress].accidentHash.push(_IpfsHash);\r\n        } else if (_category == 2) {\r\n            s_patients[_patientAddress].chronicHash.push(_IpfsHash);\r\n        } else if (_category == 3) {\r\n            s_patients[_patientAddress].acuteHash.push(_IpfsHash);\r\n        }\r\n        PatientType.Patient memory patient = s_patients[_patientAddress];\r\n        //emitting the event.\r\n        emit AddedPatient(\r\n            _patientAddress,\r\n            patient.name,\r\n            patient.chronicHash,\r\n            patient.dob,\r\n            patient.bloodGroup,\r\n            patient.dateOfRegistration,\r\n            patient.publicKey,\r\n            patient.vaccinationHash,\r\n            patient.phoneNumber,\r\n            patient.accidentHash,\r\n            patient.acuteHash\r\n        );\r\n    }\r\n\r\n    //this will be done using script by the owner\r\n    function addDoctorDetails(\r\n        address _doctorAddress,\r\n        string memory _name,\r\n        string memory _doctorRegistrationId,\r\n        uint256 _dateOfRegistration,\r\n        string memory _specialization,\r\n        address _hospitalAddress\r\n    ) external onlyOwner nonReentrant {\r\n        DoctorType.Doctor memory doctor;\r\n        doctor.name = _name;\r\n        doctor.doctorRegistrationId = _doctorRegistrationId;\r\n        doctor.doctorAddress = _doctorAddress;\r\n        doctor.dateOfRegistration = _dateOfRegistration;\r\n        doctor.specialization = _specialization;\r\n        doctor.hospitalAddress = _hospitalAddress;\r\n        s_doctors[_doctorAddress] = doctor;\r\n        //emitting the event.\r\n        emit AddedDoctor(\r\n            _doctorAddress,\r\n            doctor.name,\r\n            doctor.doctorRegistrationId,\r\n            doctor.dateOfRegistration,\r\n            doctor.specialization,\r\n            doctor.hospitalAddress\r\n        );\r\n    }\r\n\r\n    //this will be done using script by the owner\r\n    function addHospitalDetails(\r\n        address _hospitalAddress,\r\n        string memory _name,\r\n        string memory _hospitalRegistrationId,\r\n        string memory _email,\r\n        string memory _phoneNumber\r\n    ) external onlyOwner nonReentrant {\r\n        HospitalType.Hospital memory hospital = s_hospitals[_hospitalAddress];\r\n        hospital.hospitalAddress = _hospitalAddress;\r\n        hospital.name = _name;\r\n        hospital.email = _email;\r\n        hospital.phoneNumber = _phoneNumber;\r\n        hospital.hospitalRegistrationId = _hospitalRegistrationId;\r\n        hospital.dateOfRegistration = block.timestamp;\r\n        s_hospitals[_hospitalAddress] = hospital;\r\n        //emitting the event.\r\n        emit AddedHospital(\r\n            hospital.hospitalAddress,\r\n            hospital.name,\r\n            hospital.hospitalRegistrationId,\r\n            hospital.dateOfRegistration,\r\n            hospital.email,\r\n            hospital.phoneNumber\r\n        );\r\n    }\r\n\r\n    function getMyDetails() external view returns (PatientType.Patient memory) {\r\n        return s_patients[msg.sender];\r\n    }\r\n\r\n    //authorized doctor viewing patient's records\r\n    function getPatientDetails(address _patientAddress)\r\n        external\r\n        view\r\n        returns (\r\n            string memory,\r\n            string memory,\r\n            uint256\r\n        )\r\n    {\r\n        return (\r\n            s_patients[_patientAddress].name,\r\n            s_patients[_patientAddress].publicKey,\r\n            s_patients[_patientAddress].dateOfRegistration\r\n        );\r\n    }\r\n\r\n    function getPublicKey(address _patientAddress) public view returns (string memory) {\r\n        return s_addressToPublicKey[_patientAddress];\r\n    }\r\n\r\n    function getDoctorDetails(address _doctorAddress)\r\n        external\r\n        view\r\n        returns (\r\n            string memory,\r\n            string memory,\r\n            string memory,\r\n            address\r\n        )\r\n    {\r\n        return (\r\n            s_doctors[_doctorAddress].name,\r\n            s_doctors[_doctorAddress].specialization,\r\n            s_doctors[_doctorAddress].doctorRegistrationId,\r\n            s_doctors[_doctorAddress].hospitalAddress\r\n        );\r\n    }\r\n\r\n    function getHospitalDetails(address _hospitalAddress)\r\n        external\r\n        view\r\n        returns (\r\n            string memory,\r\n            string memory,\r\n            string memory\r\n        )\r\n    {\r\n        return (\r\n            s_hospitals[_hospitalAddress].name,\r\n            s_hospitals[_hospitalAddress].hospitalRegistrationId,\r\n            s_hospitals[_hospitalAddress].email\r\n        );\r\n    }\r\n\r\n    function getOwner() external view returns (address) {\r\n        return i_owner;\r\n    }\r\n}\r\n"
    },
    "contracts/PatientType.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\r\n\r\npragma solidity ^0.8.7;\r\n\r\n\r\nlibrary PatientType {\r\n    //Type Declaration\r\n    struct Patient {\r\n        string name;        //   \r\n        address patientAddress; //account address of patient     \r\n        uint256 dob;      //\r\n        string phoneNumber;\r\n        string bloodGroup;     //\r\n        string publicKey;      //for storing public key for encrypting the data\r\n        uint256 dateOfRegistration; //the date of registration of patient to the system. Tells which records are not in the system.\r\n        //Medical Records\r\n        string[] vaccinationHash; //0\r\n        string[] accidentHash; // 1\r\n        string[] chronicHash; //2\r\n        string[] acuteHash; //3\r\n    }\r\n}\r\n\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}